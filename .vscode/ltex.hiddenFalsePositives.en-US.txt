{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QS_{ij} = A_{ij} + \\begin{cases} 0                                   & \\text{if } i=0, j=0     \\\\\\\\ S_{i,j-1}                           & \\text{if } i=0          \\\\\\\\ S_{i-1,j}                           & \\text{if } j=0          \\\\\\\\ S_{i-1,j} + S_{i,j-1} - S_{i-1,j-1} & \\text{otherwise} \\end{cases}\\E$"}
{"rule":"WHITESPACE_RULE","sentence":"^\\QS_{ij} = A_{ij} + \\begin{cases} 0                                   & \\text{if } i=0, j=0     \\\\\\\\ S_{i,j-1}                           & \\text{if } i=0          \\\\\\\\ S_{i-1,j}                           & \\text{if } j=0          \\\\\\\\ S_{i-1,j} + S_{i,j-1} - S_{i-1,j-1} & \\text{otherwise} \\end{cases}\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QS_{ij} = A_{ij} + \\begin{cases} 0                                   & \\text{if } i=0, j=0     \\\\\\\\ S_{i,j-1}                           & \\text{if } i=0          \\\\\\\\ S_{i-1,j}                           & \\text{if } j=0          \\\\\\\\ S_{i-1,j} + S_{i,j-1} - S_{i-1,j-1} & \\text{otherwise} \\end{cases}\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qif we define \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q to be \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q when \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q is out of bounds.\\E$"}
{"rule":"CURRENCY","sentence":"^\\Q\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q\n\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q\n$ \\sum_{i, j} A_{ij} < 2^{64} $\nthe matrix contains at least one non-zero integer\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Q\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q\n\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q\n$ \\sum_{i, j} A_{ij} < 2^{64} $\nthe matrix contains at least one non-zero integer\\E$"}
{"rule":"AGREEMENT_SENT_START","sentence":"^\\Qtaxonomies tags = \"Algorithms\", \"Competitive Programming\", \"Graphs\", \"Backtracking\", \"C++\", \"Python\"\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Qextra math = true #math_auto_render = true keywords = \"Algorithms, Competitive programming, Graphs, Hierholzer, Backtracking, C++, Python, LeetCode, Reconstructing Itinerary\" toc = true series = \"Algorithms\" +++\\E$"}
{"rule":"THE_SUPERLATIVE","sentence":"^\\QWe are to find an itinerary that uses those tickets, such that:\nall tickets are used exactly once\nthe itinerary must be the lexicographically smallest one - for example \"\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q has a smaller lexical order than \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q\"\\E$"}
{"rule":"AGREEMENT_SENT_START","sentence":"^\\Qtaxonomies tags = \"Algorithms\", \"Competitive Programming\", \"Dynamic programming\", \"C++\"\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Qextra math = true math_auto_render = true keywords = \"Algorithms, Competitive programming, Dynamic programming\" toc = true series = \"Algorithms\" +++\\E$"}
{"rule":"AGREEMENT_SENT_START","sentence":"^\\Qtaxonomies tags = \"Algorithms\", \"Competitive Programming\", \"LeetCode\", \"Graphs\", \"Backtracking\", \"C++\", \"Python\"\\E$"}
{"rule":"THE_SUPERLATIVE","sentence":"^\\QThis goes back up the lexicographically biggest cycle, then the one smaller and so on, resulting in the cycles being spliced in the correct order\\E$"}
{"rule":"THE_SUPERLATIVE","sentence":"^\\QThis goes back up the lexicographically biggest circuit, then the one smaller and so on, resulting in the circuits being spliced in the correct order\\E$"}
{"rule":"AGREEMENT_SENT_START","sentence":"^\\Qtaxonomies tags = \"Advent Of Code\", \"Intcode\", \"Interpreters\", \"Scala\"\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Qextra #math = true #math_auto_render = true keywords = \"Algorithms, Advent of Code, Intcode, bytecode, interpreters, VM, Scala\" toc = true series = \"Advent Of Code\" +++\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\Qwe are given a comma-separated line of integers that represent an Intcode program\nIntcode is a variable-length instruction set:\nthe first integer is the opcode - either \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q or \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q\nopcode \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q is addition, taking the next three integers as its operands\nall three operands' values represent 0-based positions within the Intcode program\nthe values at the first two positions are added\nthe result is stored at the third position\nopcode \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q is multiplication, the operands are the same as with addition\nopcode \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q is \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q\nrunning an Intcode program involves\nstarting at position 0\ndecoding and executing the instruction at the current position\nonce an \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q or \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q instruction has been processed, advancing the position by 4\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\Qoperands become a case class with a method to deal with parameter modes\ninstructions are reified into an \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q sum type TODO note we've split out the state into an object Proc TODO\nself-contained thing\nconsider using given instances for tape for operands, and other stuff\nconsider renaming op to opnd or opd\\E$"}
{"rule":"A_INFINITIVE","sentence":"^\\Qoperands become a case class with a \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q method to deal with parameter modes\ninstructions are reified into an \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q sum type to ease debugging\nas the decode-execute loop now has more end-states than simply halting, we introduce a \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q sum type to encode those, making the loop stop at any of \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q or \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q\nwe wrap the decode-execute loop and state (tape and instruction pointer) in the \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q case class, which makes a copy of the tape provided at object construction time\nwe split the decode and execute parts, adding an additional entrypoint, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q to handle the input instruction\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QWe also add an \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q state for debugging purposes.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QRunning an Intcode program involves starting at position 0, decoding and executing the instruction at the current position, once an \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q or \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q instruction has been processed, advancing the position by 4, and repeating until we hit an unrecognized opcode or \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qthe first integer in each instruction can be interpreted as a zero-expanded five-digit number that encodes the following (where \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q stands for \"operand\") :\n\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q\nthere are two parameter modes we need to handle\n\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q is position mode, which causes the parameter to be interpreted as a position (address) within the program.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\Qoperands become a case class with a \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q method to deal with parameter modes\ninstructions are reified into an \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q sum type to ease debugging\nas the decode-execute loop now has more end-states than simply halting, we introduce a \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q sum type to encode those, making the loop stop at any of \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q or \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q\nwe wrap the decode-execute loop and state (tape and instruction pointer) in the \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q case class, which makes a copy of the tape provided at object construction time\nwe split the decode and execute parts, adding another entry point—\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q—to handle the input instruction\\E$"}
{"rule":"A_INFINITIVE","sentence":"^\\Qoperands become a case class with a \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q method to deal with parameter modes\ninstructions are reified into an \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q sum type to ease debugging\nas the decode-execute loop now has more end-states than simply halting, we introduce a \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q sum type to encode those, making the loop stop at any of \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q or \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q\nwe wrap the decode-execute loop and state (tape and instruction pointer) in the \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q case class, which makes a copy of the tape provided at object construction time\nwe split the decode and execute parts, adding another entry point—\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q—to handle the input instruction\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QWe also add an \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q state for debugging purposes, and rename position-mode-only parameters to \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, resulting in the complete source code being:\\E$"}
{"rule":"SOME_OF_THE","sentence":"^\\QThis change and the time it took to detect the initial issue demonstrate some of the smaller risks of suboptimal naming.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Q{{code_block_of_file(path=\"17/printMap.sc\", info_string=\"sc,linenos,hide_lines=1-101\")}}\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Qextra keywords = \"Algorithms, Advent of Code, Intcode, bytecode, interpreters, VM, Scala\" toc = true series = \"Advent Of Code\" +++\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Q{{code_block_of_file(path=\"17/printMap.sc\", info_string=\"sc, linenos, hide_lines=1-101\")}}\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qd7p2: feedback {#d7p2}\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Q{{code_block_of_file(path=\"17/printMap.sc\", info_string=\"sc, linenos, hide_lines=1-99\")}}\\E$"}
{"rule":"THE_SUPERLATIVE","sentence":"^\\QThe Intcode series of puzzles turned out to be very enjoyable to write in Scala for multiple reasons:\npattern matching, sufficiently terse syntax for algebraic data types, the standard FP vocabulary for collection manipulation, immutability by default, and an overall excellent standard library design make it a breeze to write and debug interpreters for languages of this complexity\nthe ease of mixing in more traditional features such as subtyping and mutability (and the ease of keeping that contained) are the essence of picking the right tool for the job, allowing for more straightforward solutions to many of the problems in the puzzles\nthe design choices in the syntax and libraries of the language make the path of least resistance usually the correct one in the longer term To do:\nopt hint at follow-up with Scala 3 version\nopt mention currently working up to d13\n\"while current post is an unedited experience log, that will show what the interpreter design journey might look like with the benefit of hindsight\" - questionable usefulness w/ that wording tho\nAFTER publishing and lc332 and LI response stuff:\nopt add d15p2 animation - localhost vid might not work possibly due to server missing content type stuff\nopt update following parts w/ d9p2 refactoring\nopt turn mutable case classes into plain classes\nconsider adding d21 too, if I did indeed figure it out myself, even if manually\nfix last empty line.\\E$"}
{"rule":"SOME_OF_THE","sentence":"^\\QTo demonstrate some of the improvements in Scala 3, a future update to this post might include versions of the solutions migrated to it.\\E$"}
{"rule":"THE_SUPERLATIVE","sentence":"^\\QThe Intcode series of puzzles turned out to be very enjoyable to write in Scala for multiple reasons:\npattern matching, sufficiently terse syntax for algebraic data types, the standard FP vocabulary for collection manipulation, immutability by default, and an overall excellent standard library design make it a breeze to write and debug interpreters for languages of this complexity\nthe ease of mixing in more traditional features such as subtyping and mutability (and the ease of keeping that contained) are the essence of picking the right tool for the job, allowing for more straightforward solutions to many of the problems in the puzzles\nthe design choices in the syntax and libraries of the language make the path of least resistance usually the correct one in the longer term\nthere were multiple points during the Intcode days when a new requirement turned out to already be implemented (multiple processes in day 7), or doable with a handful of lines (process cloning in day 15)\nthe usual advantages of a compiled language on a mature and performant execution platform (the JVM), that provides type inference giving a good amount of boilerplate reduction while still supporting subtyping, and generally finds a good balance between terseness and boilerplate\\E$"}
{"rule":"SOME_OF_THE","sentence":"^\\QAs an aside, to demonstrate some of the improvements in Scala 3, a future update to this post might include versions of the solutions migrated to it.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QGlobalSort/2/2 1195 ns 1200 ns 585938\nGlobalSort/2/300 92755 ns 92760 ns 7679\nGlobalSort/17/300 136764 ns 136771 ns 5133\nGlobalSort/150/300 142319 ns 142377 ns 4887\nGlobalSort/300/300 172240 ns 172328 ns 4252\nGlobalSort/2/17576 7549705 ns 7549963 ns 89\nGlobalSort/132/17576 11160039 ns 11160213 ns 62\nGlobalSort/8788/17576 15412398 ns 15412967 ns 45\nGlobalSort/17576/17576 22268916 ns 22269199 ns 31\nMinPriQ/2/2 1158 ns 1164 ns 604783\nMinPriQ/2/300 102908 ns 102910 ns 6815\nMinPriQ/17/300 128154 ns 128158 ns 5483\nMinPriQ/150/300 117985 ns 117995 ns 5928\nMinPriQ/300/300 111520 ns 111535 ns 6276\nMinPriQ/2/17576 7546353 ns 7547076 ns 91\nMinPriQ/132/17576 8115816 ns 8116409 ns 86\nMinPriQ/8788/17576 9341009 ns 9340903 ns 75\nMinPriQ/17576/17576 9616305 ns 9617470 ns 72\nMake_heap/2/2 1239 ns 1244 ns 564637\nMake_heap/2/300 112774 ns 112778 ns 6136\nMake_heap/17/300 142072 ns 142075 ns 4997\nMake_heap/150/300 133003 ns 133018 ns 5280\nMake_heap/300/300 124150 ns 124168 ns 5141\nMake_heap/2/17576 8096352 ns 8097560 ns 87\nMake_heap/132/17576 8673620 ns 8674514 ns 81\nMake_heap/8788/17576 10234246 ns 10235159 ns 68\nMake_heap/17576/17576 10576485 ns 10577092 ns 66\nLocalSort/2/2 1128 ns 1134 ns 619618\nLocalSort/2/300 78653 ns 78656 ns 8948\nLocalSort/17/300 113332 ns 113335 ns 6048\nLocalSort/150/300 106640 ns 106646 ns 6552\nLocalSort/300/300 106386 ns 106390 ns 6533\nLocalSort/2/17576 5684902 ns 5685910 ns 124\nLocalSort/132/17576 6872639 ns 6873185 ns 101\nLocalSort/8788/17576 8631884 ns 8632612 ns 80\nLocalSort/17576/17576 9266595 ns 9266908 ns 75\nMultiset/2/2 1175 ns 1180 ns 594951\nMultiset/2/300 114946 ns 114948 ns 6061\nMultiset/17/300 134931 ns 134937 ns 5250\nMultiset/150/300 120392 ns 120406 ns 5815\nMultiset/300/300 123852 ns 123876 ns 5760\nMultiset/2/17576 8035273 ns 8035510 ns 87\nMultiset/132/17576 9552130 ns 9552150 ns 73\nMultiset/8788/17576 9779385 ns 9780055 ns 71\nMultiset/17576/17576 11221352 ns 11221566 ns 62\\E$"}
{"rule":"THE_SUPERLATIVE","sentence":"^\\QLooking a bit closer, we can see that the precise requirement is choosing the next lexicographically smallest neighbor to traverse when processing a particular vertex.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QWithin the constraints of the LeetCode problem, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q means that the best case scenario (maximum outdegree of 1) might enjoy up to an 8x speedup of that part of the code compared to the worst case scenario.\\E$"}
{"rule":"AGREEMENT_SENT_START","sentence":"^\\Qtaxonomies tags = \"Algorithms\", \"Benchmarking\", \"Optimization\", \"Google Benchmark\", \"LeetCode\", \"Graphs\", \"Backtracking\", \"C++\", \"Python\"\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Qextra math = true keywords = \"Algorithms, Graphs, Hierholzer, Benchmarking, Optimization, Google Benchmark, Backtracking, C++, Python, LeetCode, Reconstructing Itinerary\" toc = true series = \"Algorithms\" +++\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qeach outgoing edge will lead to either a circuit (a closed trail coming back to the fork), or at most one open trail finishing at either the only vertex with indegree=outdegree+1 (if there is one), or at \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q\nthe one potential outgoing open trail may be traversed at any time among the other outgoing circuits, but it will be the first branch to result in backtracking.\\E$"}
{"rule":"THE_SUPERLATIVE","sentence":"^\\QLooking a bit closer, the precise requirement is to always choose the next lexicographically smallest neighbor to traverse when processing a particular vertex.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QThus, in our C++ solution we use a min priority queue (the same can be done in Python using heapq).\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QThus, in our C++ solution we use a min priority queue (the same can be done in Python using heapq).\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QWithin the constraints of the LeetCode problem, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q means that the best case scenario (maximum outdegree of 1) might enjoy up to an 8x speedup (of that part of the code specifically) compared to the worst case scenario.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qan equivalent of the global sort Python solution,\nthe minimum priority queue C++ solution,\na \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q version of the above to achieve linear adjacency list initialization per vertex,\nthe C++ multiset^multiset_codeforces solution from walkccc.me,\nand manually sorting the edges in each adjacency list.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Qan equivalent of the global sort Python solution,\nthe minimum priority queue C++ solution,\na \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q version of the above to achieve linear adjacency list initialization per vertex,\nthe C++ multiset^multiset_codeforces solution from walkccc.me,\nand manually sorting the edges in each adjacency list.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Qan equivalent of the global sort Python solution,\nthe minimum priority queue C++ solution,\na \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q version of the above to achieve linear adjacency list initialization per vertex,\nthe C++ multiset^multiset_codeforces solution from walkccc.me,\nand manually sorting the edges in each adjacency list.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Qan equivalent of the global sort Python solution,\nthe minimum priority queue C++ solution,\na \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q version of the above to achieve linear adjacency list initialization per vertex,\nthe C++ multiset^multiset_codeforces solution from walkccc.me,\nand manually sorting the edges in each adjacency list.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qminimal (2 edges),\nmaximum within the LeetCode constraints (300 edges),\nand maximum within the airport identifier constraints (\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, 17576).\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qwith the minimum node count (2 nodes),\nat the logarithmic halfway point (\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q nodes),\nat the halfway point (\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q),\nand with the minimum outdegree count of 1 (\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q).\\E$"}
{"rule":"SOME_OF_THE","sentence":"^\\QHowever, some of the local ordering approaches are slower than the global sorting one with smaller graphs.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Q{{include_file(path=\"log/o0.mdtable\")}}\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QWe generate the graphs via genEulerianGraph.sc:\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Q{{code_block_of_file(path=\"genEulerianGraph.sc\", info_string=\"sc, linenos\")}}\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Q\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q and \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q were measured to have a combined overhead of approximately 350 ns in both optimization scenarios.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QWe compile the benchmark with \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q and \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, in two configurations: with \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, and without any \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q flags.^zola_extensionless\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QWe compile the benchmark with \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q and \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, in two configurations: with \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, and without any \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q flags.^zola_extensionless\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Q\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q^arch_wiki_cpu_scaling\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QFinally, we massage the console output^google_json via bench2table.sc:\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Q^tum_complexity: TUM: Hierholzer's algorithm / More / How fast is the algorithm?\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Q^multiset_codeforces: See this Codeforces blog post for further discussion of some possible trade-offs between using \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q and \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q for priority queues.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Q^zola_extensionless: The intention is to include the used \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q once a related Zola issue is sufficiently resolved.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Q^benchmark_scaling_reporting: Google Benchmark still reports active CPU scaling in this case, as well as when using the \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q governor.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Q^arch_wiki_cpu_scaling: For further information, see Arch wiki: CPU frequency scaling.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Q^google_json: Google Benchmark also supports CSV (deprecated) and JSON output formatting.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QThus, in our C++ solution we use a min priority queue (the same can be done in Python using heapq).\\E$"}
