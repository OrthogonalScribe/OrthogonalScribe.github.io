{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QS_{ij} = A_{ij} + \\begin{cases} 0                                   & \\text{if } i=0, j=0     \\\\\\\\ S_{i,j-1}                           & \\text{if } i=0          \\\\\\\\ S_{i-1,j}                           & \\text{if } j=0          \\\\\\\\ S_{i-1,j} + S_{i,j-1} - S_{i-1,j-1} & \\text{otherwise} \\end{cases}\\E$"}
{"rule":"WHITESPACE_RULE","sentence":"^\\QS_{ij} = A_{ij} + \\begin{cases} 0                                   & \\text{if } i=0, j=0     \\\\\\\\ S_{i,j-1}                           & \\text{if } i=0          \\\\\\\\ S_{i-1,j}                           & \\text{if } j=0          \\\\\\\\ S_{i-1,j} + S_{i,j-1} - S_{i-1,j-1} & \\text{otherwise} \\end{cases}\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QS_{ij} = A_{ij} + \\begin{cases} 0                                   & \\text{if } i=0, j=0     \\\\\\\\ S_{i,j-1}                           & \\text{if } i=0          \\\\\\\\ S_{i-1,j}                           & \\text{if } j=0          \\\\\\\\ S_{i-1,j} + S_{i,j-1} - S_{i-1,j-1} & \\text{otherwise} \\end{cases}\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qif we define \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q to be \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q when \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q is out of bounds.\\E$"}
{"rule":"CURRENCY","sentence":"^\\Q\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q\n\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q\n$ \\sum_{i, j} A_{ij} < 2^{64} $\nthe matrix contains at least one non-zero integer\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Q\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q\n\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q\n$ \\sum_{i, j} A_{ij} < 2^{64} $\nthe matrix contains at least one non-zero integer\\E$"}
{"rule":"AGREEMENT_SENT_START","sentence":"^\\Qtaxonomies tags = \"Algorithms\", \"Competitive Programming\", \"Graphs\", \"Backtracking\", \"C++\", \"Python\"\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Qextra math = true #math_auto_render = true keywords = \"Algorithms, Competitive programming, Graphs, Hierholzer, Backtracking, C++, Python, LeetCode, Reconstructing Itinerary\" toc = true series = \"Algorithms\" +++\\E$"}
{"rule":"THE_SUPERLATIVE","sentence":"^\\QWe are to find an itinerary that uses those tickets, such that:\nall tickets are used exactly once\nthe itinerary must be the lexicographically smallest one - for example \"\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q has a smaller lexical order than \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q\"\\E$"}
{"rule":"AGREEMENT_SENT_START","sentence":"^\\Qtaxonomies tags = \"Algorithms\", \"Competitive Programming\", \"Dynamic programming\", \"C++\"\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Qextra math = true math_auto_render = true keywords = \"Algorithms, Competitive programming, Dynamic programming\" toc = true series = \"Algorithms\" +++\\E$"}
{"rule":"AGREEMENT_SENT_START","sentence":"^\\Qtaxonomies tags = \"Algorithms\", \"Competitive Programming\", \"LeetCode\", \"Graphs\", \"Backtracking\", \"C++\", \"Python\"\\E$"}
{"rule":"THE_SUPERLATIVE","sentence":"^\\QThis goes back up the lexicographically biggest cycle, then the one smaller and so on, resulting in the cycles being spliced in the correct order\\E$"}
{"rule":"THE_SUPERLATIVE","sentence":"^\\QThis goes back up the lexicographically biggest circuit, then the one smaller and so on, resulting in the circuits being spliced in the correct order\\E$"}
{"rule":"AGREEMENT_SENT_START","sentence":"^\\Qtaxonomies tags = \"Advent Of Code\", \"Intcode\", \"Interpreters\", \"Scala\"\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Qextra #math = true #math_auto_render = true keywords = \"Algorithms, Advent of Code, Intcode, bytecode, interpreters, VM, Scala\" toc = true series = \"Advent Of Code\" +++\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\Qwe are given a comma-separated line of integers that represent an Intcode program\nIntcode is a variable-length instruction set:\nthe first integer is the opcode - either \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q or \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q\nopcode \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q is addition, taking the next three integers as its operands\nall three operands' values represent 0-based positions within the Intcode program\nthe values at the first two positions are added\nthe result is stored at the third position\nopcode \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q is multiplication, the operands are the same as with addition\nopcode \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q is \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q\nrunning an Intcode program involves\nstarting at position 0\ndecoding and executing the instruction at the current position\nonce an \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q or \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q instruction has been processed, advancing the position by 4\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\Qoperands become a case class with a method to deal with parameter modes\ninstructions are reified into an \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q sum type TODO note we've split out the state into an object Proc TODO\nself-contained thing\nconsider using given instances for tape for operands, and other stuff\nconsider renaming op to opnd or opd\\E$"}
{"rule":"A_INFINITIVE","sentence":"^\\Qoperands become a case class with a \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q method to deal with parameter modes\ninstructions are reified into an \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q sum type to ease debugging\nas the decode-execute loop now has more end-states than simply halting, we introduce a \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q sum type to encode those, making the loop stop at any of \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q or \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q\nwe wrap the decode-execute loop and state (tape and instruction pointer) in the \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q case class, which makes a copy of the tape provided at object construction time\nwe split the decode and execute parts, adding an additional entrypoint, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q to handle the input instruction\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QWe also add an \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q state for debugging purposes.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QRunning an Intcode program involves starting at position 0, decoding and executing the instruction at the current position, once an \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q or \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q instruction has been processed, advancing the position by 4, and repeating until we hit an unrecognized opcode or \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qthe first integer in each instruction can be interpreted as a zero-expanded five-digit number that encodes the following (where \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q stands for \"operand\") :\n\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q\nthere are two parameter modes we need to handle\n\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q is position mode, which causes the parameter to be interpreted as a position (address) within the program.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\Qoperands become a case class with a \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q method to deal with parameter modes\ninstructions are reified into an \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q sum type to ease debugging\nas the decode-execute loop now has more end-states than simply halting, we introduce a \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q sum type to encode those, making the loop stop at any of \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q or \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q\nwe wrap the decode-execute loop and state (tape and instruction pointer) in the \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q case class, which makes a copy of the tape provided at object construction time\nwe split the decode and execute parts, adding another entry point—\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q—to handle the input instruction\\E$"}
{"rule":"A_INFINITIVE","sentence":"^\\Qoperands become a case class with a \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q method to deal with parameter modes\ninstructions are reified into an \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q sum type to ease debugging\nas the decode-execute loop now has more end-states than simply halting, we introduce a \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q sum type to encode those, making the loop stop at any of \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q or \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q\nwe wrap the decode-execute loop and state (tape and instruction pointer) in the \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q case class, which makes a copy of the tape provided at object construction time\nwe split the decode and execute parts, adding another entry point—\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q—to handle the input instruction\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QWe also add an \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q state for debugging purposes, and rename position-mode-only parameters to \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, resulting in the complete source code being:\\E$"}
{"rule":"SOME_OF_THE","sentence":"^\\QThis change and the time it took to detect the initial issue demonstrate some of the smaller risks of suboptimal naming.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Q{{code_block_of_file(path=\"17/printMap.sc\", info_string=\"sc,linenos,hide_lines=1-101\")}}\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Qextra keywords = \"Algorithms, Advent of Code, Intcode, bytecode, interpreters, VM, Scala\" toc = true series = \"Advent Of Code\" +++\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Q{{code_block_of_file(path=\"17/printMap.sc\", info_string=\"sc, linenos, hide_lines=1-101\")}}\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qd7p2: feedback {#d7p2}\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Q{{code_block_of_file(path=\"17/printMap.sc\", info_string=\"sc, linenos, hide_lines=1-99\")}}\\E$"}
{"rule":"THE_SUPERLATIVE","sentence":"^\\QThe Intcode series of puzzles turned out to be very enjoyable to write in Scala for multiple reasons:\npattern matching, sufficiently terse syntax for algebraic data types, the standard FP vocabulary for collection manipulation, immutability by default, and an overall excellent standard library design make it a breeze to write and debug interpreters for languages of this complexity\nthe ease of mixing in more traditional features such as subtyping and mutability (and the ease of keeping that contained) are the essence of picking the right tool for the job, allowing for more straightforward solutions to many of the problems in the puzzles\nthe design choices in the syntax and libraries of the language make the path of least resistance usually the correct one in the longer term To do:\nopt hint at follow-up with Scala 3 version\nopt mention currently working up to d13\n\"while current post is an unedited experience log, that will show what the interpreter design journey might look like with the benefit of hindsight\" - questionable usefulness w/ that wording tho\nAFTER publishing and lc332 and LI response stuff:\nopt add d15p2 animation - localhost vid might not work possibly due to server missing content type stuff\nopt update following parts w/ d9p2 refactoring\nopt turn mutable case classes into plain classes\nconsider adding d21 too, if I did indeed figure it out myself, even if manually\nfix last empty line.\\E$"}
{"rule":"SOME_OF_THE","sentence":"^\\QTo demonstrate some of the improvements in Scala 3, a future update to this post might include versions of the solutions migrated to it.\\E$"}
{"rule":"THE_SUPERLATIVE","sentence":"^\\QThe Intcode series of puzzles turned out to be very enjoyable to write in Scala for multiple reasons:\npattern matching, sufficiently terse syntax for algebraic data types, the standard FP vocabulary for collection manipulation, immutability by default, and an overall excellent standard library design make it a breeze to write and debug interpreters for languages of this complexity\nthe ease of mixing in more traditional features such as subtyping and mutability (and the ease of keeping that contained) are the essence of picking the right tool for the job, allowing for more straightforward solutions to many of the problems in the puzzles\nthe design choices in the syntax and libraries of the language make the path of least resistance usually the correct one in the longer term\nthere were multiple points during the Intcode days when a new requirement turned out to already be implemented (multiple processes in day 7), or doable with a handful of lines (process cloning in day 15)\nthe usual advantages of a compiled language on a mature and performant execution platform (the JVM), that provides type inference giving a good amount of boilerplate reduction while still supporting subtyping, and generally finds a good balance between terseness and boilerplate\\E$"}
{"rule":"SOME_OF_THE","sentence":"^\\QAs an aside, to demonstrate some of the improvements in Scala 3, a future update to this post might include versions of the solutions migrated to it.\\E$"}
