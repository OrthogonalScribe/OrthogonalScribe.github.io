{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QS_{ij} = A_{ij} + \\begin{cases} 0                                   & \\text{if } i=0, j=0     \\\\\\\\ S_{i,j-1}                           & \\text{if } i=0          \\\\\\\\ S_{i-1,j}                           & \\text{if } j=0          \\\\\\\\ S_{i-1,j} + S_{i,j-1} - S_{i-1,j-1} & \\text{otherwise} \\end{cases}\\E$"}
{"rule":"WHITESPACE_RULE","sentence":"^\\QS_{ij} = A_{ij} + \\begin{cases} 0                                   & \\text{if } i=0, j=0     \\\\\\\\ S_{i,j-1}                           & \\text{if } i=0          \\\\\\\\ S_{i-1,j}                           & \\text{if } j=0          \\\\\\\\ S_{i-1,j} + S_{i,j-1} - S_{i-1,j-1} & \\text{otherwise} \\end{cases}\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QS_{ij} = A_{ij} + \\begin{cases} 0                                   & \\text{if } i=0, j=0     \\\\\\\\ S_{i,j-1}                           & \\text{if } i=0          \\\\\\\\ S_{i-1,j}                           & \\text{if } j=0          \\\\\\\\ S_{i-1,j} + S_{i,j-1} - S_{i-1,j-1} & \\text{otherwise} \\end{cases}\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qif we define \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q to be \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q when \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q is out of bounds.\\E$"}
{"rule":"CURRENCY","sentence":"^\\Q\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q\n\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q\n$ \\sum_{i, j} A_{ij} < 2^{64} $\nthe matrix contains at least one non-zero integer\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Q\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q\n\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q\n$ \\sum_{i, j} A_{ij} < 2^{64} $\nthe matrix contains at least one non-zero integer\\E$"}
{"rule":"AGREEMENT_SENT_START","sentence":"^\\Qtaxonomies tags = \"Algorithms\", \"Competitive Programming\", \"Graphs\", \"Backtracking\", \"C++\", \"Python\"\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Qextra math = true #math_auto_render = true keywords = \"Algorithms, Competitive programming, Graphs, Hierholzer, Backtracking, C++, Python, LeetCode, Reconstructing Itinerary\" toc = true series = \"Algorithms\" +++\\E$"}
{"rule":"THE_SUPERLATIVE","sentence":"^\\QWe are to find an itinerary that uses those tickets, such that:\nall tickets are used exactly once\nthe itinerary must be the lexicographically smallest one - for example \"\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q has a smaller lexical order than \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q\"\\E$"}
{"rule":"AGREEMENT_SENT_START","sentence":"^\\Qtaxonomies tags = \"Algorithms\", \"Competitive Programming\", \"Dynamic programming\", \"C++\"\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Qextra math = true math_auto_render = true keywords = \"Algorithms, Competitive programming, Dynamic programming\" toc = true series = \"Algorithms\" +++\\E$"}
{"rule":"AGREEMENT_SENT_START","sentence":"^\\Qtaxonomies tags = \"Algorithms\", \"Competitive Programming\", \"LeetCode\", \"Graphs\", \"Backtracking\", \"C++\", \"Python\"\\E$"}
{"rule":"THE_SUPERLATIVE","sentence":"^\\QThis goes back up the lexicographically biggest cycle, then the one smaller and so on, resulting in the cycles being spliced in the correct order\\E$"}
{"rule":"THE_SUPERLATIVE","sentence":"^\\QThis goes back up the lexicographically biggest circuit, then the one smaller and so on, resulting in the circuits being spliced in the correct order\\E$"}
